package defpackage.marsh;


// Code generated by colf(1); DO NOT EDIT.


import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamException;
import java.io.OutputStream;
import java.io.Serializable;
import java.nio.BufferOverflowException;
import java.nio.BufferUnderflowException;
import java.nio.charset.StandardCharsets;
import java.util.InputMismatchException;

import static java.lang.String.format;


/**
 * Data bean with built-in serialization support.

 * @author generated by colf(1)
 * @see <a href="https://github.com/pascaldekloe/colfer">Colfer's home</a>
 */
@javax.annotation.Generated(value = "colf(1)", comments = "Colfer from schema file structdef.colf")
public class ASRC implements Serializable {

    /**
     * The upper limit for serial byte sizes.
     */
    public static int colferSizeMax = 16 * 1024 * 1024;


    public String by;

    public short rnd;

    public String form;

    public String model;

    public String os;

    public String api;

    public String uid;

    public String IP;

    public String regcode;

    public String mobile;

    public String vrfcode;


    /**
     * Default constructor
     */
    public ASRC() {
        init();
    }


    /**
     * Colfer zero values.
     */
    private void init() {
        by = "";
        form = "";
        model = "";
        os = "";
        api = "";
        uid = "";
        IP = "";
        regcode = "";
        mobile = "";
        vrfcode = "";
    }

    /**
     * {@link #reset(InputStream) Reusable} deserialization of Colfer streams.
     */
    public static class Unmarshaller {

        /**
         * The data source.
         */
        protected InputStream in;

        /**
         * The read buffer.
         */
        public byte[] buf;

        /**
         * The {@link #buf buffer}'s data start index, inclusive.
         */
        protected int offset;

        /**
         * The {@link #buf buffer}'s data end index, exclusive.
         */
        protected int i;


        /**
         * @param in  the data source or {@code null}.
         * @param buf the initial buffer or {@code null}.
         */
        public Unmarshaller(InputStream in, byte[] buf) {
            // TODO: better size estimation
            if (buf == null || buf.length == 0)
                buf = new byte[Math.min(ASRC.colferSizeMax, 2048)];
            this.buf = buf;
            reset(in);
        }

        /**
         * Reuses the marshaller.
         *
         * @param in the data source or {@code null}.
         * @throws IllegalStateException on pending data.
         */
        public void reset(InputStream in) {
            if (this.i != this.offset) throw new IllegalStateException("colfer: pending data");
            this.in = in;
            this.offset = 0;
            this.i = 0;
        }

        /**
         * Deserializes the following object.
         *
         * @return the result or {@code null} when EOF.
         * @throws IOException            from the input stream.
         * @throws SecurityException      on an upper limit breach defined by {@link #colferSizeMax}.
         * @throws InputMismatchException when the data does not match this object's schema.
         */
        public ASRC next() throws IOException {
            if (in == null) return null;

            while (true) {
                if (this.i > this.offset) {
                    try {
                        ASRC o = new ASRC();
                        this.offset = o.unmarshal(this.buf, this.offset, this.i);
                        return o;
                    } catch (BufferUnderflowException e) {
                    }
                }
                // not enough data

                if (this.i <= this.offset) {
                    this.offset = 0;
                    this.i = 0;
                } else if (i == buf.length) {
                    byte[] src = this.buf;
                    // TODO: better size estimation
                    if (offset == 0)
                        this.buf = new byte[Math.min(ASRC.colferSizeMax, this.buf.length * 4)];
                    System.arraycopy(src, this.offset, this.buf, 0, this.i - this.offset);
                    this.i -= this.offset;
                    this.offset = 0;
                }
                assert this.i < this.buf.length;

                int n = in.read(buf, i, buf.length - i);
                if (n < 0) {
                    if (this.i > this.offset)
                        throw new InputMismatchException("colfer: pending data with EOF");
                    return null;
                }
                assert n > 0;
                i += n;
            }
        }

    }


    /**
     * Serializes the object.
     *
     * @param out the data destination.
     * @param buf the initial buffer or {@code null}.
     * @return the final buffer. When the serial fits into {@code buf} then the return is {@code buf}.
     * Otherwise the return is a new buffer, large enough to hold the whole serial.
     * @throws IOException           from {@code out}.
     * @throws IllegalStateException on an upper limit breach defined by {@link #colferSizeMax}.
     */
    public byte[] marshal(OutputStream out, byte[] buf) throws IOException {
        // TODO: better size estimation
        if (buf == null || buf.length == 0)
            buf = new byte[Math.min(ASRC.colferSizeMax, 2048)];

        while (true) {
            int i;
            try {
                i = marshal(buf, 0);
            } catch (BufferOverflowException e) {
                buf = new byte[Math.min(ASRC.colferSizeMax, buf.length * 4)];
                continue;
            }

            out.write(buf, 0, i);
            return buf;
        }
    }

    /**
     * Serializes the object.
     *
     * @param buf    the data destination.
     * @param offset the initial index for {@code buf}, inclusive.
     * @return the final index for {@code buf}, exclusive.
     * @throws BufferOverflowException when {@code buf} is too small.
     * @throws IllegalStateException   on an upper limit breach defined by {@link #colferSizeMax}.
     */
    public int marshal(byte[] buf, int offset) {
        int i = offset;

        try {
            if (!this.by.isEmpty()) {
                buf[i++] = (byte) 0;
                int start = ++i;

                String s = this.by;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRC.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRC.by size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (this.rnd != 0) {
                short x = this.rnd;
                if ((x & (short) 0xff00) != 0) {
                    buf[i++] = (byte) 1;
                    buf[i++] = (byte) (x >>> 8);
                } else {
                    buf[i++] = (byte) (1 | 0x80);
                }
                buf[i++] = (byte) x;
            }

            if (!this.form.isEmpty()) {
                buf[i++] = (byte) 2;
                int start = ++i;

                String s = this.form;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRC.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRC.form size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.model.isEmpty()) {
                buf[i++] = (byte) 3;
                int start = ++i;

                String s = this.model;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRC.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRC.model size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.os.isEmpty()) {
                buf[i++] = (byte) 4;
                int start = ++i;

                String s = this.os;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRC.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRC.os size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.api.isEmpty()) {
                buf[i++] = (byte) 5;
                int start = ++i;

                String s = this.api;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRC.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRC.api size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.uid.isEmpty()) {
                buf[i++] = (byte) 6;
                int start = ++i;

                String s = this.uid;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRC.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRC.uid size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.IP.isEmpty()) {
                buf[i++] = (byte) 7;
                int start = ++i;

                String s = this.IP;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRC.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRC.IP size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.regcode.isEmpty()) {
                buf[i++] = (byte) 8;
                int start = ++i;

                String s = this.regcode;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRC.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRC.regcode size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.mobile.isEmpty()) {
                buf[i++] = (byte) 9;
                int start = ++i;

                String s = this.mobile;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRC.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRC.mobile size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.vrfcode.isEmpty()) {
                buf[i++] = (byte) 10;
                int start = ++i;

                String s = this.vrfcode;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRC.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRC.vrfcode size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            buf[i++] = (byte) 0x7f;
            return i;
        } catch (ArrayIndexOutOfBoundsException e) {
            if (i - offset > ASRC.colferSizeMax)
                throw new IllegalStateException(format("colfer: main.ASRC exceeds %d bytes", ASRC.colferSizeMax));
            if (i > buf.length) throw new BufferOverflowException();
            throw e;
        }
    }

    /**
     * Deserializes the object.
     *
     * @param buf    the data source.
     * @param offset the initial index for {@code buf}, inclusive.
     * @return the final index for {@code buf}, exclusive.
     * @throws BufferUnderflowException when {@code buf} is incomplete. (EOF)
     * @throws SecurityException        on an upper limit breach defined by {@link #colferSizeMax}.
     * @throws InputMismatchException   when the data does not match this object's schema.
     */
    public int unmarshal(byte[] buf, int offset) {
        return unmarshal(buf, offset, buf.length);
    }

    /**
     * Deserializes the object.
     *
     * @param buf    the data source.
     * @param offset the initial index for {@code buf}, inclusive.
     * @param end    the index limit for {@code buf}, exclusive.
     * @return the final index for {@code buf}, exclusive.
     * @throws BufferUnderflowException when {@code buf} is incomplete. (EOF)
     * @throws SecurityException        on an upper limit breach defined by {@link #colferSizeMax}.
     * @throws InputMismatchException   when the data does not match this object's schema.
     */
    public int unmarshal(byte[] buf, int offset, int end) {
        if (end > buf.length) end = buf.length;
        int i = offset;

        try {
            byte header = buf[i++];

            if (header == (byte) 0) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRC.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRC.by size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int start = i;
                i += size;
                this.by = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 1) {
                this.rnd = (short) ((buf[i++] & 0xff) << 8 | (buf[i++] & 0xff));
                header = buf[i++];
            } else if (header == (byte) (1 | 0x80)) {
                this.rnd = (short) (buf[i++] & 0xff);
                header = buf[i++];
            }

            if (header == (byte) 2) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRC.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRC.form size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int start = i;
                i += size;
                this.form = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 3) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRC.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRC.model size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int start = i;
                i += size;
                this.model = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 4) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRC.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRC.os size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int start = i;
                i += size;
                this.os = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 5) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRC.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRC.api size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int start = i;
                i += size;
                this.api = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 6) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRC.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRC.uid size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int start = i;
                i += size;
                this.uid = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 7) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRC.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRC.IP size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int start = i;
                i += size;
                this.IP = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 8) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRC.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRC.regcode size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int start = i;
                i += size;
                this.regcode = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 9) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRC.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRC.mobile size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int start = i;
                i += size;
                this.mobile = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 10) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRC.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRC.vrfcode size %d exceeds %d UTF-8 bytes", size, ASRC.colferSizeMax));

                int start = i;
                i += size;
                this.vrfcode = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header != (byte) 0x7f)
                throw new InputMismatchException(format("colfer: unknown header at byte %d", i - 1));
        } finally {
            if (i > end && end - offset < ASRC.colferSizeMax) throw new BufferUnderflowException();
            if (i < 0 || i - offset > ASRC.colferSizeMax)
                throw new SecurityException(format("colfer: main.ASRC exceeds %d bytes", ASRC.colferSizeMax));
            if (i > end) throw new BufferUnderflowException();
        }

        return i;
    }

    // {@link Serializable} version number.
    private static final long serialVersionUID = 11L;

    // {@link Serializable} Colfer extension.
    private void writeObject(ObjectOutputStream out) throws IOException {
        // TODO: better size estimation
        byte[] buf = new byte[1024];
        int n;
        while (true) try {
            n = marshal(buf, 0);
            break;
        } catch (BufferUnderflowException e) {
            buf = new byte[4 * buf.length];
        }

        out.writeInt(n);
        out.write(buf, 0, n);
    }

    // {@link Serializable} Colfer extension.
    private void readObject(ObjectInputStream in) throws ClassNotFoundException, IOException {
        init();

        int n = in.readInt();
        byte[] buf = new byte[n];
        in.readFully(buf);
        unmarshal(buf, 0);
    }

    // {@link Serializable} Colfer extension.
    private void readObjectNoData() throws ObjectStreamException {
        init();
    }

    /**
     * Gets main.ASRC.by.
     *
     * @return the value.
     */
    public String getBy() {
        return this.by;
    }

    /**
     * Sets main.ASRC.by.
     *
     * @param value the replacement.
     */
    public void setBy(String value) {
        this.by = value;
    }

    /**
     * Sets main.ASRC.by.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRC withBy(String value) {
        this.by = value;
        return this;
    }

    /**
     * Gets main.ASRC.rnd.
     *
     * @return the value.
     */
    public short getRnd() {
        return this.rnd;
    }

    /**
     * Sets main.ASRC.rnd.
     *
     * @param value the replacement.
     */
    public void setRnd(short value) {
        this.rnd = value;
    }

    /**
     * Sets main.ASRC.rnd.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRC withRnd(short value) {
        this.rnd = value;
        return this;
    }

    /**
     * Gets main.ASRC.form.
     *
     * @return the value.
     */
    public String getForm() {
        return this.form;
    }

    /**
     * Sets main.ASRC.form.
     *
     * @param value the replacement.
     */
    public void setForm(String value) {
        this.form = value;
    }

    /**
     * Sets main.ASRC.form.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRC withForm(String value) {
        this.form = value;
        return this;
    }

    /**
     * Gets main.ASRC.model.
     *
     * @return the value.
     */
    public String getModel() {
        return this.model;
    }

    /**
     * Sets main.ASRC.model.
     *
     * @param value the replacement.
     */
    public void setModel(String value) {
        this.model = value;
    }

    /**
     * Sets main.ASRC.model.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRC withModel(String value) {
        this.model = value;
        return this;
    }

    /**
     * Gets main.ASRC.os.
     *
     * @return the value.
     */
    public String getOs() {
        return this.os;
    }

    /**
     * Sets main.ASRC.os.
     *
     * @param value the replacement.
     */
    public void setOs(String value) {
        this.os = value;
    }

    /**
     * Sets main.ASRC.os.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRC withOs(String value) {
        this.os = value;
        return this;
    }

    /**
     * Gets main.ASRC.api.
     *
     * @return the value.
     */
    public String getApi() {
        return this.api;
    }

    /**
     * Sets main.ASRC.api.
     *
     * @param value the replacement.
     */
    public void setApi(String value) {
        this.api = value;
    }

    /**
     * Sets main.ASRC.api.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRC withApi(String value) {
        this.api = value;
        return this;
    }

    /**
     * Gets main.ASRC.uid.
     *
     * @return the value.
     */
    public String getUid() {
        return this.uid;
    }

    /**
     * Sets main.ASRC.uid.
     *
     * @param value the replacement.
     */
    public void setUid(String value) {
        this.uid = value;
    }

    /**
     * Sets main.ASRC.uid.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRC withUid(String value) {
        this.uid = value;
        return this;
    }

    /**
     * Gets main.ASRC.IP.
     *
     * @return the value.
     */
    public String getIP() {
        return this.IP;
    }

    /**
     * Sets main.ASRC.IP.
     *
     * @param value the replacement.
     */
    public void setIP(String value) {
        this.IP = value;
    }

    /**
     * Sets main.ASRC.IP.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRC withIP(String value) {
        this.IP = value;
        return this;
    }

    /**
     * Gets main.ASRC.regcode.
     *
     * @return the value.
     */
    public String getRegcode() {
        return this.regcode;
    }

    /**
     * Sets main.ASRC.regcode.
     *
     * @param value the replacement.
     */
    public void setRegcode(String value) {
        this.regcode = value;
    }

    /**
     * Sets main.ASRC.regcode.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRC withRegcode(String value) {
        this.regcode = value;
        return this;
    }

    /**
     * Gets main.ASRC.mobile.
     *
     * @return the value.
     */
    public String getMobile() {
        return this.mobile;
    }

    /**
     * Sets main.ASRC.mobile.
     *
     * @param value the replacement.
     */
    public void setMobile(String value) {
        this.mobile = value;
    }

    /**
     * Sets main.ASRC.mobile.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRC withMobile(String value) {
        this.mobile = value;
        return this;
    }

    /**
     * Gets main.ASRC.vrfcode.
     *
     * @return the value.
     */
    public String getVrfcode() {
        return this.vrfcode;
    }

    /**
     * Sets main.ASRC.vrfcode.
     *
     * @param value the replacement.
     */
    public void setVrfcode(String value) {
        this.vrfcode = value;
    }

    /**
     * Sets main.ASRC.vrfcode.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRC withVrfcode(String value) {
        this.vrfcode = value;
        return this;
    }

    @Override
    public final int hashCode() {
        int h = 1;
        if (this.by != null) h = 31 * h + this.by.hashCode();
        h = 31 * h + (this.rnd & 0xffff);
        if (this.form != null) h = 31 * h + this.form.hashCode();
        if (this.model != null) h = 31 * h + this.model.hashCode();
        if (this.os != null) h = 31 * h + this.os.hashCode();
        if (this.api != null) h = 31 * h + this.api.hashCode();
        if (this.uid != null) h = 31 * h + this.uid.hashCode();
        if (this.IP != null) h = 31 * h + this.IP.hashCode();
        if (this.regcode != null) h = 31 * h + this.regcode.hashCode();
        if (this.mobile != null) h = 31 * h + this.mobile.hashCode();
        if (this.vrfcode != null) h = 31 * h + this.vrfcode.hashCode();
        return h;
    }

    @Override
    public final boolean equals(Object o) {
        return o instanceof ASRC && equals((ASRC) o);
    }

    public final boolean equals(ASRC o) {
        if (o == null) return false;
        if (o == this) return true;
        return o.getClass() == ASRC.class
                && (this.by == null ? o.by == null : this.by.equals(o.by))
                && this.rnd == o.rnd
                && (this.form == null ? o.form == null : this.form.equals(o.form))
                && (this.model == null ? o.model == null : this.model.equals(o.model))
                && (this.os == null ? o.os == null : this.os.equals(o.os))
                && (this.api == null ? o.api == null : this.api.equals(o.api))
                && (this.uid == null ? o.uid == null : this.uid.equals(o.uid))
                && (this.IP == null ? o.IP == null : this.IP.equals(o.IP))
                && (this.regcode == null ? o.regcode == null : this.regcode.equals(o.regcode))
                && (this.mobile == null ? o.mobile == null : this.mobile.equals(o.mobile))
                && (this.vrfcode == null ? o.vrfcode == null : this.vrfcode.equals(o.vrfcode));
    }

}
