package defpackage.marsh;


// Code generated by colf(1); DO NOT EDIT.


import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamException;
import java.io.OutputStream;
import java.io.Serializable;
import java.nio.BufferOverflowException;
import java.nio.BufferUnderflowException;
import java.nio.charset.StandardCharsets;
import java.util.InputMismatchException;

import static java.lang.String.format;


/**
 * Data bean with built-in serialization support.

 * @author generated by colf(1)
 * @see <a href="https://github.com/pascaldekloe/colfer">Colfer's home</a>
 */
@javax.annotation.Generated(value = "colf(1)", comments = "Colfer from schema file structdef.colf")
public class ASRR implements Serializable {

    /**
     * The upper limit for serial byte sizes.
     */
    public static int colferSizeMax = 16 * 1024 * 1024;


    public short rnd;

    public String form;

    public String model;

    public String os;

    public String api;

    public String uid;

    public String IP;

    public String mcc1;

    public String mcc2;

    public String lang;


    /**
     * Default constructor
     */
    public ASRR() {
        init();
    }


    /**
     * Colfer zero values.
     */
    private void init() {
        form = "";
        model = "";
        os = "";
        api = "";
        uid = "";
        IP = "";
        mcc1 = "";
        mcc2 = "";
        lang = "";
    }

    /**
     * {@link #reset(InputStream) Reusable} deserialization of Colfer streams.
     */
    public static class Unmarshaller {

        /**
         * The data source.
         */
        protected InputStream in;

        /**
         * The read buffer.
         */
        public byte[] buf;

        /**
         * The {@link #buf buffer}'s data start index, inclusive.
         */
        protected int offset;

        /**
         * The {@link #buf buffer}'s data end index, exclusive.
         */
        protected int i;


        /**
         * @param in  the data source or {@code null}.
         * @param buf the initial buffer or {@code null}.
         */
        public Unmarshaller(InputStream in, byte[] buf) {
            // TODO: better size estimation
            if (buf == null || buf.length == 0)
                buf = new byte[Math.min(ASRR.colferSizeMax, 2048)];
            this.buf = buf;
            reset(in);
        }

        /**
         * Reuses the marshaller.
         *
         * @param in the data source or {@code null}.
         * @throws IllegalStateException on pending data.
         */
        public void reset(InputStream in) {
            if (this.i != this.offset) throw new IllegalStateException("colfer: pending data");
            this.in = in;
            this.offset = 0;
            this.i = 0;
        }

        /**
         * Deserializes the following object.
         *
         * @return the result or {@code null} when EOF.
         * @throws IOException            from the input stream.
         * @throws SecurityException      on an upper limit breach defined by {@link #colferSizeMax}.
         * @throws InputMismatchException when the data does not match this object's schema.
         */
        public ASRR next() throws IOException {
            if (in == null) return null;

            while (true) {
                if (this.i > this.offset) {
                    try {
                        ASRR o = new ASRR();
                        this.offset = o.unmarshal(this.buf, this.offset, this.i);
                        return o;
                    } catch (BufferUnderflowException e) {
                    }
                }
                // not enough data

                if (this.i <= this.offset) {
                    this.offset = 0;
                    this.i = 0;
                } else if (i == buf.length) {
                    byte[] src = this.buf;
                    // TODO: better size estimation
                    if (offset == 0)
                        this.buf = new byte[Math.min(ASRR.colferSizeMax, this.buf.length * 4)];
                    System.arraycopy(src, this.offset, this.buf, 0, this.i - this.offset);
                    this.i -= this.offset;
                    this.offset = 0;
                }
                assert this.i < this.buf.length;

                int n = in.read(buf, i, buf.length - i);
                if (n < 0) {
                    if (this.i > this.offset)
                        throw new InputMismatchException("colfer: pending data with EOF");
                    return null;
                }
                assert n > 0;
                i += n;
            }
        }

    }


    /**
     * Serializes the object.
     *
     * @param out the data destination.
     * @param buf the initial buffer or {@code null}.
     * @return the final buffer. When the serial fits into {@code buf} then the return is {@code buf}.
     * Otherwise the return is a new buffer, large enough to hold the whole serial.
     * @throws IOException           from {@code out}.
     * @throws IllegalStateException on an upper limit breach defined by {@link #colferSizeMax}.
     */
    public byte[] marshal(OutputStream out, byte[] buf) throws IOException {
        // TODO: better size estimation
        if (buf == null || buf.length == 0)
            buf = new byte[Math.min(ASRR.colferSizeMax, 2048)];

        while (true) {
            int i;
            try {
                i = marshal(buf, 0);
            } catch (BufferOverflowException e) {
                buf = new byte[Math.min(ASRR.colferSizeMax, buf.length * 4)];
                continue;
            }

            out.write(buf, 0, i);
            return buf;
        }
    }

    /**
     * Serializes the object.
     *
     * @param buf    the data destination.
     * @param offset the initial index for {@code buf}, inclusive.
     * @return the final index for {@code buf}, exclusive.
     * @throws BufferOverflowException when {@code buf} is too small.
     * @throws IllegalStateException   on an upper limit breach defined by {@link #colferSizeMax}.
     */
    public int marshal(byte[] buf, int offset) {
        int i = offset;

        try {
            if (this.rnd != 0) {
                short x = this.rnd;
                if ((x & (short) 0xff00) != 0) {
                    buf[i++] = (byte) 0;
                    buf[i++] = (byte) (x >>> 8);
                } else {
                    buf[i++] = (byte) (0 | 0x80);
                }
                buf[i++] = (byte) x;
            }

            if (!this.form.isEmpty()) {
                buf[i++] = (byte) 1;
                int start = ++i;

                String s = this.form;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRR.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRR.form size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.model.isEmpty()) {
                buf[i++] = (byte) 2;
                int start = ++i;

                String s = this.model;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRR.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRR.model size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.os.isEmpty()) {
                buf[i++] = (byte) 3;
                int start = ++i;

                String s = this.os;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRR.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRR.os size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.api.isEmpty()) {
                buf[i++] = (byte) 4;
                int start = ++i;

                String s = this.api;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRR.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRR.api size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.uid.isEmpty()) {
                buf[i++] = (byte) 5;
                int start = ++i;

                String s = this.uid;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRR.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRR.uid size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.IP.isEmpty()) {
                buf[i++] = (byte) 6;
                int start = ++i;

                String s = this.IP;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRR.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRR.IP size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.mcc1.isEmpty()) {
                buf[i++] = (byte) 7;
                int start = ++i;

                String s = this.mcc1;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRR.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRR.mcc1 size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.mcc2.isEmpty()) {
                buf[i++] = (byte) 8;
                int start = ++i;

                String s = this.mcc2;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRR.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRR.mcc2 size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            if (!this.lang.isEmpty()) {
                buf[i++] = (byte) 9;
                int start = ++i;

                String s = this.lang;
                for (int sIndex = 0, sLength = s.length(); sIndex < sLength; sIndex++) {
                    char c = s.charAt(sIndex);
                    if (c < '\u0080') {
                        buf[i++] = (byte) c;
                    } else if (c < '\u0800') {
                        buf[i++] = (byte) (192 | c >>> 6);
                        buf[i++] = (byte) (128 | c & 63);
                    } else if (c < '\ud800' || c > '\udfff') {
                        buf[i++] = (byte) (224 | c >>> 12);
                        buf[i++] = (byte) (128 | c >>> 6 & 63);
                        buf[i++] = (byte) (128 | c & 63);
                    } else {
                        int cp = 0;
                        if (++sIndex < sLength) cp = Character.toCodePoint(c, s.charAt(sIndex));
                        if ((cp >= 1 << 16) && (cp < 1 << 21)) {
                            buf[i++] = (byte) (240 | cp >>> 18);
                            buf[i++] = (byte) (128 | cp >>> 12 & 63);
                            buf[i++] = (byte) (128 | cp >>> 6 & 63);
                            buf[i++] = (byte) (128 | cp & 63);
                        } else
                            buf[i++] = (byte) '?';
                    }
                }
                int size = i - start;
                if (size > ASRR.colferSizeMax)
                    throw new IllegalStateException(format("colfer: main.ASRR.lang size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int ii = start - 1;
                if (size > 0x7f) {
                    i++;
                    for (int x = size; x >= 1 << 14; x >>>= 7) i++;
                    System.arraycopy(buf, start, buf, i - size, size);

                    do {
                        buf[ii++] = (byte) (size | 0x80);
                        size >>>= 7;
                    } while (size > 0x7f);
                }
                buf[ii] = (byte) size;
            }

            buf[i++] = (byte) 0x7f;
            return i;
        } catch (ArrayIndexOutOfBoundsException e) {
            if (i - offset > ASRR.colferSizeMax)
                throw new IllegalStateException(format("colfer: main.ASRR exceeds %d bytes", ASRR.colferSizeMax));
            if (i > buf.length) throw new BufferOverflowException();
            throw e;
        }
    }

    /**
     * Deserializes the object.
     *
     * @param buf    the data source.
     * @param offset the initial index for {@code buf}, inclusive.
     * @return the final index for {@code buf}, exclusive.
     * @throws BufferUnderflowException when {@code buf} is incomplete. (EOF)
     * @throws SecurityException        on an upper limit breach defined by {@link #colferSizeMax}.
     * @throws InputMismatchException   when the data does not match this object's schema.
     */
    public int unmarshal(byte[] buf, int offset) {
        return unmarshal(buf, offset, buf.length);
    }

    /**
     * Deserializes the object.
     *
     * @param buf    the data source.
     * @param offset the initial index for {@code buf}, inclusive.
     * @param end    the index limit for {@code buf}, exclusive.
     * @return the final index for {@code buf}, exclusive.
     * @throws BufferUnderflowException when {@code buf} is incomplete. (EOF)
     * @throws SecurityException        on an upper limit breach defined by {@link #colferSizeMax}.
     * @throws InputMismatchException   when the data does not match this object's schema.
     */
    public int unmarshal(byte[] buf, int offset, int end) {
        if (end > buf.length) end = buf.length;
        int i = offset;

        try {
            byte header = buf[i++];

            if (header == (byte) 0) {
                this.rnd = (short) ((buf[i++] & 0xff) << 8 | (buf[i++] & 0xff));
                header = buf[i++];
            } else if (header == (byte) (0 | 0x80)) {
                this.rnd = (short) (buf[i++] & 0xff);
                header = buf[i++];
            }

            if (header == (byte) 1) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRR.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRR.form size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int start = i;
                i += size;
                this.form = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 2) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRR.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRR.model size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int start = i;
                i += size;
                this.model = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 3) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRR.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRR.os size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int start = i;
                i += size;
                this.os = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 4) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRR.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRR.api size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int start = i;
                i += size;
                this.api = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 5) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRR.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRR.uid size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int start = i;
                i += size;
                this.uid = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 6) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRR.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRR.IP size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int start = i;
                i += size;
                this.IP = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 7) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRR.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRR.mcc1 size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int start = i;
                i += size;
                this.mcc1 = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 8) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRR.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRR.mcc2 size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int start = i;
                i += size;
                this.mcc2 = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header == (byte) 9) {
                int size = 0;
                for (int shift = 0; true; shift += 7) {
                    byte b = buf[i++];
                    size |= (b & 0x7f) << shift;
                    if (shift == 28 || b >= 0) break;
                }
                if (size < 0 || size > ASRR.colferSizeMax)
                    throw new SecurityException(format("colfer: main.ASRR.lang size %d exceeds %d UTF-8 bytes", size, ASRR.colferSizeMax));

                int start = i;
                i += size;
                this.lang = new String(buf, start, size, StandardCharsets.UTF_8);
                header = buf[i++];
            }

            if (header != (byte) 0x7f)
                throw new InputMismatchException(format("colfer: unknown header at byte %d", i - 1));
        } finally {
            if (i > end && end - offset < ASRR.colferSizeMax) throw new BufferUnderflowException();
            if (i < 0 || i - offset > ASRR.colferSizeMax)
                throw new SecurityException(format("colfer: main.ASRR exceeds %d bytes", ASRR.colferSizeMax));
            if (i > end) throw new BufferUnderflowException();
        }

        return i;
    }

    // {@link Serializable} version number.
    private static final long serialVersionUID = 10L;

    // {@link Serializable} Colfer extension.
    private void writeObject(ObjectOutputStream out) throws IOException {
        // TODO: better size estimation
        byte[] buf = new byte[1024];
        int n;
        while (true) try {
            n = marshal(buf, 0);
            break;
        } catch (BufferUnderflowException e) {
            buf = new byte[4 * buf.length];
        }

        out.writeInt(n);
        out.write(buf, 0, n);
    }

    // {@link Serializable} Colfer extension.
    private void readObject(ObjectInputStream in) throws ClassNotFoundException, IOException {
        init();

        int n = in.readInt();
        byte[] buf = new byte[n];
        in.readFully(buf);
        unmarshal(buf, 0);
    }

    // {@link Serializable} Colfer extension.
    private void readObjectNoData() throws ObjectStreamException {
        init();
    }

    /**
     * Gets main.ASRR.rnd.
     *
     * @return the value.
     */
    public short getRnd() {
        return this.rnd;
    }

    /**
     * Sets main.ASRR.rnd.
     *
     * @param value the replacement.
     */
    public void setRnd(short value) {
        this.rnd = value;
    }

    /**
     * Sets main.ASRR.rnd.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRR withRnd(short value) {
        this.rnd = value;
        return this;
    }

    /**
     * Gets main.ASRR.form.
     *
     * @return the value.
     */
    public String getForm() {
        return this.form;
    }

    /**
     * Sets main.ASRR.form.
     *
     * @param value the replacement.
     */
    public void setForm(String value) {
        this.form = value;
    }

    /**
     * Sets main.ASRR.form.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRR withForm(String value) {
        this.form = value;
        return this;
    }

    /**
     * Gets main.ASRR.model.
     *
     * @return the value.
     */
    public String getModel() {
        return this.model;
    }

    /**
     * Sets main.ASRR.model.
     *
     * @param value the replacement.
     */
    public void setModel(String value) {
        this.model = value;
    }

    /**
     * Sets main.ASRR.model.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRR withModel(String value) {
        this.model = value;
        return this;
    }

    /**
     * Gets main.ASRR.os.
     *
     * @return the value.
     */
    public String getOs() {
        return this.os;
    }

    /**
     * Sets main.ASRR.os.
     *
     * @param value the replacement.
     */
    public void setOs(String value) {
        this.os = value;
    }

    /**
     * Sets main.ASRR.os.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRR withOs(String value) {
        this.os = value;
        return this;
    }

    /**
     * Gets main.ASRR.api.
     *
     * @return the value.
     */
    public String getApi() {
        return this.api;
    }

    /**
     * Sets main.ASRR.api.
     *
     * @param value the replacement.
     */
    public void setApi(String value) {
        this.api = value;
    }

    /**
     * Sets main.ASRR.api.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRR withApi(String value) {
        this.api = value;
        return this;
    }

    /**
     * Gets main.ASRR.uid.
     *
     * @return the value.
     */
    public String getUid() {
        return this.uid;
    }

    /**
     * Sets main.ASRR.uid.
     *
     * @param value the replacement.
     */
    public void setUid(String value) {
        this.uid = value;
    }

    /**
     * Sets main.ASRR.uid.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRR withUid(String value) {
        this.uid = value;
        return this;
    }

    /**
     * Gets main.ASRR.IP.
     *
     * @return the value.
     */
    public String getIP() {
        return this.IP;
    }

    /**
     * Sets main.ASRR.IP.
     *
     * @param value the replacement.
     */
    public void setIP(String value) {
        this.IP = value;
    }

    /**
     * Sets main.ASRR.IP.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRR withIP(String value) {
        this.IP = value;
        return this;
    }

    /**
     * Gets main.ASRR.mcc1.
     *
     * @return the value.
     */
    public String getMcc1() {
        return this.mcc1;
    }

    /**
     * Sets main.ASRR.mcc1.
     *
     * @param value the replacement.
     */
    public void setMcc1(String value) {
        this.mcc1 = value;
    }

    /**
     * Sets main.ASRR.mcc1.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRR withMcc1(String value) {
        this.mcc1 = value;
        return this;
    }

    /**
     * Gets main.ASRR.mcc2.
     *
     * @return the value.
     */
    public String getMcc2() {
        return this.mcc2;
    }

    /**
     * Sets main.ASRR.mcc2.
     *
     * @param value the replacement.
     */
    public void setMcc2(String value) {
        this.mcc2 = value;
    }

    /**
     * Sets main.ASRR.mcc2.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRR withMcc2(String value) {
        this.mcc2 = value;
        return this;
    }

    /**
     * Gets main.ASRR.lang.
     *
     * @return the value.
     */
    public String getLang() {
        return this.lang;
    }

    /**
     * Sets main.ASRR.lang.
     *
     * @param value the replacement.
     */
    public void setLang(String value) {
        this.lang = value;
    }

    /**
     * Sets main.ASRR.lang.
     *
     * @param value the replacement.
     * @return {link this}.
     */
    public ASRR withLang(String value) {
        this.lang = value;
        return this;
    }

    @Override
    public final int hashCode() {
        int h = 1;
        h = 31 * h + (this.rnd & 0xffff);
        if (this.form != null) h = 31 * h + this.form.hashCode();
        if (this.model != null) h = 31 * h + this.model.hashCode();
        if (this.os != null) h = 31 * h + this.os.hashCode();
        if (this.api != null) h = 31 * h + this.api.hashCode();
        if (this.uid != null) h = 31 * h + this.uid.hashCode();
        if (this.IP != null) h = 31 * h + this.IP.hashCode();
        if (this.mcc1 != null) h = 31 * h + this.mcc1.hashCode();
        if (this.mcc2 != null) h = 31 * h + this.mcc2.hashCode();
        if (this.lang != null) h = 31 * h + this.lang.hashCode();
        return h;
    }

    @Override
    public final boolean equals(Object o) {
        return o instanceof ASRR && equals((ASRR) o);
    }

    public final boolean equals(ASRR o) {
        if (o == null) return false;
        if (o == this) return true;
        return o.getClass() == ASRR.class
                && this.rnd == o.rnd
                && (this.form == null ? o.form == null : this.form.equals(o.form))
                && (this.model == null ? o.model == null : this.model.equals(o.model))
                && (this.os == null ? o.os == null : this.os.equals(o.os))
                && (this.api == null ? o.api == null : this.api.equals(o.api))
                && (this.uid == null ? o.uid == null : this.uid.equals(o.uid))
                && (this.IP == null ? o.IP == null : this.IP.equals(o.IP))
                && (this.mcc1 == null ? o.mcc1 == null : this.mcc1.equals(o.mcc1))
                && (this.mcc2 == null ? o.mcc2 == null : this.mcc2.equals(o.mcc2))
                && (this.lang == null ? o.lang == null : this.lang.equals(o.lang));
    }

}
