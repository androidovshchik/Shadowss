// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file structdef.colf for package main.

#include "Colfer.h"
#include <errno.h>
#include <stdlib.h>

#if defined(__BYTE_ORDER) && __BYTE_ORDER == __BIG_ENDIAN || \
    defined(__BIG_ENDIAN__) || \
    defined(__ARMEB__) || \
    defined(__AARCH64EB__) || \
    defined(_MIPSEB) || defined(__MIPSEB) || defined(__MIPSEB__) || \
    defined(__SYSC_ZARCH__)
#define COLFER_ENDIAN
#endif


size_t colfer_size_max = 16 * 1024 * 1024;
size_t colfer_list_max = 64 * 1024;



size_t main_ASPI_marshal_len(const main_ASPI* o) {
	size_t l = 1;

	{
		uint_fast16_t x = o->rnd;
		if (x) l += x < 256 ? 2 : 3;
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_ASPI_marshal(const main_ASPI* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		uint_fast16_t x = o->rnd;
		if (x) {
			if (x < 256)  {
				*p++ = 0 | 0x80;

				*p++ = x;
			} else {
				*p++ = 0;

				*p++ = x >> 8;
				*p++ = x;
			}
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_ASPI_unmarshal(main_ASPI* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p+2 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast16_t x = *p++;
		x <<= 8;
		o->rnd = x | *p++;
		header = *p++;
	} else if (header == (0 | 128)) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->rnd = *p++;
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_SAPO_marshal_len(const main_SAPO* o) {
	size_t l = 1;

	{
		uint_fast16_t x = o->rnd;
		if (x) l += x < 256 ? 2 : 3;
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_SAPO_marshal(const main_SAPO* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		uint_fast16_t x = o->rnd;
		if (x) {
			if (x < 256)  {
				*p++ = 0 | 0x80;

				*p++ = x;
			} else {
				*p++ = 0;

				*p++ = x >> 8;
				*p++ = x;
			}
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_SAPO_unmarshal(main_SAPO* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p+2 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast16_t x = *p++;
		x <<= 8;
		o->rnd = x | *p++;
		header = *p++;
	} else if (header == (0 | 128)) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->rnd = *p++;
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_ASPO_marshal_len(const main_ASPO* o) {
	size_t l = 1;

	{
		uint_fast16_t x = o->rnd;
		if (x) l += x < 256 ? 2 : 3;
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_ASPO_marshal(const main_ASPO* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		uint_fast16_t x = o->rnd;
		if (x) {
			if (x < 256)  {
				*p++ = 0 | 0x80;

				*p++ = x;
			} else {
				*p++ = 0;

				*p++ = x >> 8;
				*p++ = x;
			}
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_ASPO_unmarshal(main_ASPO* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p+2 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast16_t x = *p++;
		x <<= 8;
		o->rnd = x | *p++;
		header = *p++;
	} else if (header == (0 | 128)) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->rnd = *p++;
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_SAPI_marshal_len(const main_SAPI* o) {
	size_t l = 1;

	{
		uint_fast16_t x = o->rnd;
		if (x) l += x < 256 ? 2 : 3;
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_SAPI_marshal(const main_SAPI* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		uint_fast16_t x = o->rnd;
		if (x) {
			if (x < 256)  {
				*p++ = 0 | 0x80;

				*p++ = x;
			} else {
				*p++ = 0;

				*p++ = x >> 8;
				*p++ = x;
			}
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_SAPI_unmarshal(main_SAPI* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p+2 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast16_t x = *p++;
		x <<= 8;
		o->rnd = x | *p++;
		header = *p++;
	} else if (header == (0 | 128)) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->rnd = *p++;
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_ASRR_marshal_len(const main_ASRR* o) {
	size_t l = 1;

	{
		uint_fast16_t x = o->rnd;
		if (x) l += x < 256 ? 2 : 3;
	}

	{
		size_t n = o->form.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->model.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->os.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->api.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->uid.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->IP.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->mcc1.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->mcc2.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->lang.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_ASRR_marshal(const main_ASRR* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		uint_fast16_t x = o->rnd;
		if (x) {
			if (x < 256)  {
				*p++ = 0 | 0x80;

				*p++ = x;
			} else {
				*p++ = 0;

				*p++ = x >> 8;
				*p++ = x;
			}
		}
	}

	{
		size_t n = o->form.len;
		if (n) {
			*p++ = 1;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->form.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->model.len;
		if (n) {
			*p++ = 2;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->model.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->os.len;
		if (n) {
			*p++ = 3;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->os.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->api.len;
		if (n) {
			*p++ = 4;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->api.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->uid.len;
		if (n) {
			*p++ = 5;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->uid.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->IP.len;
		if (n) {
			*p++ = 6;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->IP.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->mcc1.len;
		if (n) {
			*p++ = 7;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->mcc1.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->mcc2.len;
		if (n) {
			*p++ = 8;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->mcc2.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->lang.len;
		if (n) {
			*p++ = 9;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->lang.utf8, n);
			p += n;
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_ASRR_unmarshal(main_ASRR* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p+2 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast16_t x = *p++;
		x <<= 8;
		o->rnd = x | *p++;
		header = *p++;
	} else if (header == (0 | 128)) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->rnd = *p++;
		header = *p++;
	}

	if (header == 1) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->form.len = n;

		void* a = malloc(n);
		o->form.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 2) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->model.len = n;

		void* a = malloc(n);
		o->model.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 3) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->os.len = n;

		void* a = malloc(n);
		o->os.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 4) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->api.len = n;

		void* a = malloc(n);
		o->api.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 5) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->uid.len = n;

		void* a = malloc(n);
		o->uid.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 6) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->IP.len = n;

		void* a = malloc(n);
		o->IP.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 7) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->mcc1.len = n;

		void* a = malloc(n);
		o->mcc1.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 8) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->mcc2.len = n;

		void* a = malloc(n);
		o->mcc2.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 9) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->lang.len = n;

		void* a = malloc(n);
		o->lang.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_SARR_marshal_len(const main_SARR* o) {
	size_t l = 1;

	{
		uint_fast16_t x = o->rnd;
		if (x) l += x < 256 ? 2 : 3;
	}

	{
		size_t n = o->form.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->error.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->dataerr.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->data.len;
		if (n) {
			if (n > colfer_list_max) {
				errno = EFBIG;
				return 0;
			}
			main_RGI1_data* a = o->data.list;
			for (size_t i = 0; i < n; ++i) l += main_RGI1_data_marshal_len(&a[i]);
			for (l += 2; n > 127; n >>= 7, ++l);
			if (l > colfer_size_max) {
				errno = EFBIG;
				return 0;
			}
		}
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_SARR_marshal(const main_SARR* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		uint_fast16_t x = o->rnd;
		if (x) {
			if (x < 256)  {
				*p++ = 0 | 0x80;

				*p++ = x;
			} else {
				*p++ = 0;

				*p++ = x >> 8;
				*p++ = x;
			}
		}
	}

	{
		size_t n = o->form.len;
		if (n) {
			*p++ = 1;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->form.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->error.len;
		if (n) {
			*p++ = 2;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->error.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->dataerr.len;
		if (n) {
			*p++ = 3;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->dataerr.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->data.len;
		if (n) {
			*p++ = 4;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			main_RGI1_data* a = o->data.list;
			for (size_t i = 0; i < n; ++i) p += main_RGI1_data_marshal(&a[i], p);
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_SARR_unmarshal(main_SARR* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p+2 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast16_t x = *p++;
		x <<= 8;
		o->rnd = x | *p++;
		header = *p++;
	} else if (header == (0 | 128)) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->rnd = *p++;
		header = *p++;
	}

	if (header == 1) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->form.len = n;

		void* a = malloc(n);
		o->form.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 2) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->error.len = n;

		void* a = malloc(n);
		o->error.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 3) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->dataerr.len = n;

		void* a = malloc(n);
		o->dataerr.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 4) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; ; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_list_max) {
			errno = EFBIG;
			return 0;
		}

		main_RGI1_data* a = calloc(n, sizeof(main_RGI1_data));
		for (size_t i = 0; i < n; ++i) {
			size_t read = main_RGI1_data_unmarshal(&a[i], p, (size_t) (end - p));
			if (!read) {
				if (errno == EWOULDBLOCK) errno = enderr;
				return read;
			}
			p += read;
		}
		o->data.len = n;
		o->data.list = a;

		if (p >= end) {
			errno = enderr;
			return 0;
		}
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_RGI1_data_marshal_len(const main_RGI1_data* o) {
	size_t l = 1;

	{
		size_t n = o->country.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->regcode.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	if (o->min) l += 2;

	if (o->max) l += 2;

	{
		size_t n = o->numex.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_RGI1_data_marshal(const main_RGI1_data* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		size_t n = o->country.len;
		if (n) {
			*p++ = 0;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->country.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->regcode.len;
		if (n) {
			*p++ = 1;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->regcode.utf8, n);
			p += n;
		}
	}

	if (o->min) {
		*p++ = 2;

		*p++ = o->min;
	}

	if (o->max) {
		*p++ = 3;

		*p++ = o->max;
	}

	{
		size_t n = o->numex.len;
		if (n) {
			*p++ = 4;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->numex.utf8, n);
			p += n;
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_RGI1_data_unmarshal(main_RGI1_data* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->country.len = n;

		void* a = malloc(n);
		o->country.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 1) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->regcode.len = n;

		void* a = malloc(n);
		o->regcode.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 2) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->min = *p++;
		header = *p++;
	}

	if (header == 3) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->max = *p++;
		header = *p++;
	}

	if (header == 4) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->numex.len = n;

		void* a = malloc(n);
		o->numex.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_ASRV_marshal_len(const main_ASRV* o) {
	size_t l = 1;

	{
		uint_fast16_t x = o->rnd;
		if (x) l += x < 256 ? 2 : 3;
	}

	{
		size_t n = o->form.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->model.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->os.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->api.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->uid.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->IP.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->ver.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_ASRV_marshal(const main_ASRV* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		uint_fast16_t x = o->rnd;
		if (x) {
			if (x < 256)  {
				*p++ = 0 | 0x80;

				*p++ = x;
			} else {
				*p++ = 0;

				*p++ = x >> 8;
				*p++ = x;
			}
		}
	}

	{
		size_t n = o->form.len;
		if (n) {
			*p++ = 1;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->form.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->model.len;
		if (n) {
			*p++ = 2;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->model.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->os.len;
		if (n) {
			*p++ = 3;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->os.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->api.len;
		if (n) {
			*p++ = 4;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->api.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->uid.len;
		if (n) {
			*p++ = 5;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->uid.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->IP.len;
		if (n) {
			*p++ = 6;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->IP.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->ver.len;
		if (n) {
			*p++ = 7;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->ver.utf8, n);
			p += n;
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_ASRV_unmarshal(main_ASRV* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p+2 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast16_t x = *p++;
		x <<= 8;
		o->rnd = x | *p++;
		header = *p++;
	} else if (header == (0 | 128)) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->rnd = *p++;
		header = *p++;
	}

	if (header == 1) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->form.len = n;

		void* a = malloc(n);
		o->form.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 2) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->model.len = n;

		void* a = malloc(n);
		o->model.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 3) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->os.len = n;

		void* a = malloc(n);
		o->os.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 4) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->api.len = n;

		void* a = malloc(n);
		o->api.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 5) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->uid.len = n;

		void* a = malloc(n);
		o->uid.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 6) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->IP.len = n;

		void* a = malloc(n);
		o->IP.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 7) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->ver.len = n;

		void* a = malloc(n);
		o->ver.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_SARV_marshal_len(const main_SARV* o) {
	size_t l = 1;

	{
		uint_fast16_t x = o->rnd;
		if (x) l += x < 256 ? 2 : 3;
	}

	{
		size_t n = o->form.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->error.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->dataerr.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_SARV_marshal(const main_SARV* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		uint_fast16_t x = o->rnd;
		if (x) {
			if (x < 256)  {
				*p++ = 0 | 0x80;

				*p++ = x;
			} else {
				*p++ = 0;

				*p++ = x >> 8;
				*p++ = x;
			}
		}
	}

	{
		size_t n = o->form.len;
		if (n) {
			*p++ = 1;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->form.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->error.len;
		if (n) {
			*p++ = 2;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->error.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->dataerr.len;
		if (n) {
			*p++ = 3;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->dataerr.utf8, n);
			p += n;
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_SARV_unmarshal(main_SARV* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p+2 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast16_t x = *p++;
		x <<= 8;
		o->rnd = x | *p++;
		header = *p++;
	} else if (header == (0 | 128)) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->rnd = *p++;
		header = *p++;
	}

	if (header == 1) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->form.len = n;

		void* a = malloc(n);
		o->form.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 2) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->error.len = n;

		void* a = malloc(n);
		o->error.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 3) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->dataerr.len = n;

		void* a = malloc(n);
		o->dataerr.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_ASRM_marshal_len(const main_ASRM* o) {
	size_t l = 1;

	{
		uint_fast16_t x = o->rnd;
		if (x) l += x < 256 ? 2 : 3;
	}

	{
		size_t n = o->form.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->model.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->os.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->api.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->uid.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->IP.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->regcode.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->mobile.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->utype.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->imsi1.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->imsi2.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->mcc1.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->mcc2.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_ASRM_marshal(const main_ASRM* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		uint_fast16_t x = o->rnd;
		if (x) {
			if (x < 256)  {
				*p++ = 0 | 0x80;

				*p++ = x;
			} else {
				*p++ = 0;

				*p++ = x >> 8;
				*p++ = x;
			}
		}
	}

	{
		size_t n = o->form.len;
		if (n) {
			*p++ = 1;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->form.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->model.len;
		if (n) {
			*p++ = 2;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->model.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->os.len;
		if (n) {
			*p++ = 3;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->os.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->api.len;
		if (n) {
			*p++ = 4;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->api.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->uid.len;
		if (n) {
			*p++ = 5;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->uid.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->IP.len;
		if (n) {
			*p++ = 6;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->IP.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->regcode.len;
		if (n) {
			*p++ = 7;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->regcode.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->mobile.len;
		if (n) {
			*p++ = 8;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->mobile.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->utype.len;
		if (n) {
			*p++ = 9;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->utype.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->imsi1.len;
		if (n) {
			*p++ = 10;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->imsi1.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->imsi2.len;
		if (n) {
			*p++ = 11;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->imsi2.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->mcc1.len;
		if (n) {
			*p++ = 12;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->mcc1.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->mcc2.len;
		if (n) {
			*p++ = 13;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->mcc2.utf8, n);
			p += n;
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_ASRM_unmarshal(main_ASRM* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p+2 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast16_t x = *p++;
		x <<= 8;
		o->rnd = x | *p++;
		header = *p++;
	} else if (header == (0 | 128)) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->rnd = *p++;
		header = *p++;
	}

	if (header == 1) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->form.len = n;

		void* a = malloc(n);
		o->form.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 2) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->model.len = n;

		void* a = malloc(n);
		o->model.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 3) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->os.len = n;

		void* a = malloc(n);
		o->os.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 4) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->api.len = n;

		void* a = malloc(n);
		o->api.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 5) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->uid.len = n;

		void* a = malloc(n);
		o->uid.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 6) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->IP.len = n;

		void* a = malloc(n);
		o->IP.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 7) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->regcode.len = n;

		void* a = malloc(n);
		o->regcode.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 8) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->mobile.len = n;

		void* a = malloc(n);
		o->mobile.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 9) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->utype.len = n;

		void* a = malloc(n);
		o->utype.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 10) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->imsi1.len = n;

		void* a = malloc(n);
		o->imsi1.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 11) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->imsi2.len = n;

		void* a = malloc(n);
		o->imsi2.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 12) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->mcc1.len = n;

		void* a = malloc(n);
		o->mcc1.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 13) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->mcc2.len = n;

		void* a = malloc(n);
		o->mcc2.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_SARM_marshal_len(const main_SARM* o) {
	size_t l = 1;

	{
		uint_fast16_t x = o->rnd;
		if (x) l += x < 256 ? 2 : 3;
	}

	{
		size_t n = o->form.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->error.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->dataerr.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->usid.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->token.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_SARM_marshal(const main_SARM* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		uint_fast16_t x = o->rnd;
		if (x) {
			if (x < 256)  {
				*p++ = 0 | 0x80;

				*p++ = x;
			} else {
				*p++ = 0;

				*p++ = x >> 8;
				*p++ = x;
			}
		}
	}

	{
		size_t n = o->form.len;
		if (n) {
			*p++ = 1;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->form.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->error.len;
		if (n) {
			*p++ = 2;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->error.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->dataerr.len;
		if (n) {
			*p++ = 3;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->dataerr.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->usid.len;
		if (n) {
			*p++ = 4;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->usid.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->token.len;
		if (n) {
			*p++ = 5;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->token.utf8, n);
			p += n;
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_SARM_unmarshal(main_SARM* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p+2 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast16_t x = *p++;
		x <<= 8;
		o->rnd = x | *p++;
		header = *p++;
	} else if (header == (0 | 128)) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->rnd = *p++;
		header = *p++;
	}

	if (header == 1) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->form.len = n;

		void* a = malloc(n);
		o->form.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 2) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->error.len = n;

		void* a = malloc(n);
		o->error.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 3) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->dataerr.len = n;

		void* a = malloc(n);
		o->dataerr.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 4) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->usid.len = n;

		void* a = malloc(n);
		o->usid.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 5) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->token.len = n;

		void* a = malloc(n);
		o->token.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_ASRC_marshal_len(const main_ASRC* o) {
	size_t l = 1;

	{
		size_t n = o->by.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		uint_fast16_t x = o->rnd;
		if (x) l += x < 256 ? 2 : 3;
	}

	{
		size_t n = o->form.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->model.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->os.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->api.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->uid.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->IP.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->regcode.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->mobile.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->vrfcode.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_ASRC_marshal(const main_ASRC* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		size_t n = o->by.len;
		if (n) {
			*p++ = 0;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->by.utf8, n);
			p += n;
		}
	}

	{
		uint_fast16_t x = o->rnd;
		if (x) {
			if (x < 256)  {
				*p++ = 1 | 0x80;

				*p++ = x;
			} else {
				*p++ = 1;

				*p++ = x >> 8;
				*p++ = x;
			}
		}
	}

	{
		size_t n = o->form.len;
		if (n) {
			*p++ = 2;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->form.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->model.len;
		if (n) {
			*p++ = 3;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->model.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->os.len;
		if (n) {
			*p++ = 4;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->os.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->api.len;
		if (n) {
			*p++ = 5;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->api.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->uid.len;
		if (n) {
			*p++ = 6;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->uid.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->IP.len;
		if (n) {
			*p++ = 7;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->IP.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->regcode.len;
		if (n) {
			*p++ = 8;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->regcode.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->mobile.len;
		if (n) {
			*p++ = 9;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->mobile.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->vrfcode.len;
		if (n) {
			*p++ = 10;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->vrfcode.utf8, n);
			p += n;
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_ASRC_unmarshal(main_ASRC* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->by.len = n;

		void* a = malloc(n);
		o->by.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 1) {
		if (p+2 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast16_t x = *p++;
		x <<= 8;
		o->rnd = x | *p++;
		header = *p++;
	} else if (header == (1 | 128)) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->rnd = *p++;
		header = *p++;
	}

	if (header == 2) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->form.len = n;

		void* a = malloc(n);
		o->form.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 3) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->model.len = n;

		void* a = malloc(n);
		o->model.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 4) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->os.len = n;

		void* a = malloc(n);
		o->os.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 5) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->api.len = n;

		void* a = malloc(n);
		o->api.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 6) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->uid.len = n;

		void* a = malloc(n);
		o->uid.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 7) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->IP.len = n;

		void* a = malloc(n);
		o->IP.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 8) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->regcode.len = n;

		void* a = malloc(n);
		o->regcode.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 9) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->mobile.len = n;

		void* a = malloc(n);
		o->mobile.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 10) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->vrfcode.len = n;

		void* a = malloc(n);
		o->vrfcode.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_ASAU_marshal_len(const main_ASAU* o) {
	size_t l = 1;

	{
		size_t n = o->token.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		uint_fast64_t x = o->time;
		if (x) {
			if (x >= (uint_fast64_t) 1 << 49) l += 9;
			else for (l += 2; x > 127; x >>= 7, ++l);
		}
	}

	if (o->timezone != 0.0f) l += 5;

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_ASAU_marshal(const main_ASAU* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		size_t n = o->token.len;
		if (n) {
			*p++ = 0;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->token.utf8, n);
			p += n;
		}
	}

	{
		uint_fast64_t x = o->time;
		if (x) {
			if (x < (uint_fast64_t) 1 << 49) {
				*p++ = 1;
				for (; x >= 128; x >>= 7) *p++ = x | 128;
				*p++ = x;
			} else {
				*p++ = 1 | 128;
#ifdef COLFER_ENDIAN
				memcpy(p, &o->time, 8);
				p += 8;
#else
				*p++ = x >> 56;
				*p++ = x >> 48;
				*p++ = x >> 40;
				*p++ = x >> 32;
				*p++ = x >> 24;
				*p++ = x >> 16;
				*p++ = x >> 8;
				*p++ = x;
#endif
			}
		}
	}

	if (o->timezone != 0.0f) {
		*p++ = 2;

#ifdef COLFER_ENDIAN
		memcpy(p, &o->timezone, 4);
		p += 4;
#else
		uint_fast32_t x;
		memcpy(&x, &o->timezone, 4);
		*p++ = x >> 24;
		*p++ = x >> 16;
		*p++ = x >> 8;
		*p++ = x;
#endif
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_ASAU_unmarshal(main_ASAU* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->token.len = n;

		void* a = malloc(n);
		o->token.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 1) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast64_t x = *p++;
		if (x > 127) {
			x &= 127;
			for (int shift = 7; ; shift += 7) {
				uint_fast64_t b = *p++;
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				if (b <= 127) {
					x |= b << shift;
					break;
				}
				x |= (b & 127) << shift;
			}
		}
		o->time = x;
		header = *p++;
	} else if (header == (1 | 128)) {
		if (p+8 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast64_t x = *p++;
		x <<= 56;
		x |= (uint_fast64_t) *p++ << 48;
		x |= (uint_fast64_t) *p++ << 40;
		x |= (uint_fast64_t) *p++ << 32;
		x |= (uint_fast64_t) *p++ << 24;
		x |= (uint_fast64_t) *p++ << 16;
		x |= (uint_fast64_t) *p++ << 8;
		x |= (uint_fast64_t) *p++;
		o->time = x;
		header = *p++;
	}

	if (header == 2) {
		if (p+4 >= end) {
			errno = enderr;
			return 0;
		}
#ifdef COLFER_ENDIAN
		memcpy(&o->timezone, p, 4);
		p += 4;
#else
		uint_fast32_t x = *p++;
		x <<= 24;
		x |= (uint_fast32_t) *p++ << 16;
		x |= (uint_fast32_t) *p++ << 8;
		x |= (uint_fast32_t) *p++;
		memcpy(&o->timezone, &x, 4);
#endif
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_CSNG_marshal_len(const main_CSNG* o) {
	size_t l = 1;

	{
		size_t n = o->m.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	if (o->glon != 0.0) l += 9;

	if (o->glat != 0.0) l += 9;

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_CSNG_marshal(const main_CSNG* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		size_t n = o->m.len;
		if (n) {
			*p++ = 0;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->m.utf8, n);
			p += n;
		}
	}

	if (o->glon != 0.0) {
		*p++ = 1;

#ifdef COLFER_ENDIAN
		memcpy(p, &o->glon, 8);
		p += 8;
#else
		uint_fast64_t x;
		memcpy(&x, &o->glon, 8);
		*p++ = x >> 56;
		*p++ = x >> 48;
		*p++ = x >> 40;
		*p++ = x >> 32;
		*p++ = x >> 24;
		*p++ = x >> 16;
		*p++ = x >> 8;
		*p++ = x;
#endif
	}

	if (o->glat != 0.0) {
		*p++ = 2;

#ifdef COLFER_ENDIAN
		memcpy(p, &o->glat, 8);
		p += 8;
#else
		uint_fast64_t x;
		memcpy(&x, &o->glat, 8);
		*p++ = x >> 56;
		*p++ = x >> 48;
		*p++ = x >> 40;
		*p++ = x >> 32;
		*p++ = x >> 24;
		*p++ = x >> 16;
		*p++ = x >> 8;
		*p++ = x;
#endif
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_CSNG_unmarshal(main_CSNG* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->m.len = n;

		void* a = malloc(n);
		o->m.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 1) {
		if (p+8 >= end) {
			errno = enderr;
			return 0;
		}
#ifdef COLFER_ENDIAN
		memcpy(&o->glon, p, 8);
		p += 8;
#else
		uint_fast64_t x = *p++;
		x <<= 56;
		x |= (uint_fast64_t) *p++ << 48;
		x |= (uint_fast64_t) *p++ << 40;
		x |= (uint_fast64_t) *p++ << 32;
		x |= (uint_fast64_t) *p++ << 24;
		x |= (uint_fast64_t) *p++ << 16;
		x |= (uint_fast64_t) *p++ << 8;
		x |= (uint_fast64_t) *p++;
		memcpy(&o->glon, &x, 8);
#endif
		header = *p++;
	}

	if (header == 2) {
		if (p+8 >= end) {
			errno = enderr;
			return 0;
		}
#ifdef COLFER_ENDIAN
		memcpy(&o->glat, p, 8);
		p += 8;
#else
		uint_fast64_t x = *p++;
		x <<= 56;
		x |= (uint_fast64_t) *p++ << 48;
		x |= (uint_fast64_t) *p++ << 40;
		x |= (uint_fast64_t) *p++ << 32;
		x |= (uint_fast64_t) *p++ << 24;
		x |= (uint_fast64_t) *p++ << 16;
		x |= (uint_fast64_t) *p++ << 8;
		x |= (uint_fast64_t) *p++;
		memcpy(&o->glat, &x, 8);
#endif
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_SCNG_marshal_len(const main_SCNG* o) {
	size_t l = 1;

	{
		size_t n = o->m.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_SCNG_marshal(const main_SCNG* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		size_t n = o->m.len;
		if (n) {
			*p++ = 0;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->m.utf8, n);
			p += n;
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_SCNG_unmarshal(main_SCNG* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->m.len = n;

		void* a = malloc(n);
		o->m.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_MSNG_marshal_len(const main_MSNG* o) {
	size_t l = 1;

	{
		uint_fast16_t x = o->x;
		if (x) l += x < 256 ? 2 : 3;
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_MSNG_marshal(const main_MSNG* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		uint_fast16_t x = o->x;
		if (x) {
			if (x < 256)  {
				*p++ = 0 | 0x80;

				*p++ = x;
			} else {
				*p++ = 0;

				*p++ = x >> 8;
				*p++ = x;
			}
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_MSNG_unmarshal(main_MSNG* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p+2 >= end) {
			errno = enderr;
			return 0;
		}
		uint_fast16_t x = *p++;
		x <<= 8;
		o->x = x | *p++;
		header = *p++;
	} else if (header == (0 | 128)) {
		if (p+1 >= end) {
			errno = enderr;
			return 0;
		}
		o->x = *p++;
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_SMNG_marshal_len(const main_SMNG* o) {
	size_t l = 1;

	{
		size_t n = o->c.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	if (o->glon != 0.0) l += 9;

	if (o->glat != 0.0) l += 9;

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_SMNG_marshal(const main_SMNG* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		size_t n = o->c.len;
		if (n) {
			*p++ = 0;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->c.utf8, n);
			p += n;
		}
	}

	if (o->glon != 0.0) {
		*p++ = 1;

#ifdef COLFER_ENDIAN
		memcpy(p, &o->glon, 8);
		p += 8;
#else
		uint_fast64_t x;
		memcpy(&x, &o->glon, 8);
		*p++ = x >> 56;
		*p++ = x >> 48;
		*p++ = x >> 40;
		*p++ = x >> 32;
		*p++ = x >> 24;
		*p++ = x >> 16;
		*p++ = x >> 8;
		*p++ = x;
#endif
	}

	if (o->glat != 0.0) {
		*p++ = 2;

#ifdef COLFER_ENDIAN
		memcpy(p, &o->glat, 8);
		p += 8;
#else
		uint_fast64_t x;
		memcpy(&x, &o->glat, 8);
		*p++ = x >> 56;
		*p++ = x >> 48;
		*p++ = x >> 40;
		*p++ = x >> 32;
		*p++ = x >> 24;
		*p++ = x >> 16;
		*p++ = x >> 8;
		*p++ = x;
#endif
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_SMNG_unmarshal(main_SMNG* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->c.len = n;

		void* a = malloc(n);
		o->c.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 1) {
		if (p+8 >= end) {
			errno = enderr;
			return 0;
		}
#ifdef COLFER_ENDIAN
		memcpy(&o->glon, p, 8);
		p += 8;
#else
		uint_fast64_t x = *p++;
		x <<= 56;
		x |= (uint_fast64_t) *p++ << 48;
		x |= (uint_fast64_t) *p++ << 40;
		x |= (uint_fast64_t) *p++ << 32;
		x |= (uint_fast64_t) *p++ << 24;
		x |= (uint_fast64_t) *p++ << 16;
		x |= (uint_fast64_t) *p++ << 8;
		x |= (uint_fast64_t) *p++;
		memcpy(&o->glon, &x, 8);
#endif
		header = *p++;
	}

	if (header == 2) {
		if (p+8 >= end) {
			errno = enderr;
			return 0;
		}
#ifdef COLFER_ENDIAN
		memcpy(&o->glat, p, 8);
		p += 8;
#else
		uint_fast64_t x = *p++;
		x <<= 56;
		x |= (uint_fast64_t) *p++ << 48;
		x |= (uint_fast64_t) *p++ << 40;
		x |= (uint_fast64_t) *p++ << 32;
		x |= (uint_fast64_t) *p++ << 24;
		x |= (uint_fast64_t) *p++ << 16;
		x |= (uint_fast64_t) *p++ << 8;
		x |= (uint_fast64_t) *p++;
		memcpy(&o->glat, &x, 8);
#endif
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}

size_t main_ASER_marshal_len(const main_ASER* o) {
	size_t l = 1;

	{
		size_t n = o->form.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->model.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->os.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->api.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->uid.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->IP.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->ver.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->usid.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->errortype.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	{
		size_t n = o->dataerr.len;
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (n) for (l += 2 + n; n > 127; n >>= 7, ++l);
	}

	if (l > colfer_size_max) {
		errno = EFBIG;
		return 0;
	}
	return l;
}

size_t main_ASER_marshal(const main_ASER* o, void* buf) {
	// octet pointer navigation
	uint8_t* p = buf;

	{
		size_t n = o->form.len;
		if (n) {
			*p++ = 0;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->form.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->model.len;
		if (n) {
			*p++ = 1;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->model.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->os.len;
		if (n) {
			*p++ = 2;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->os.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->api.len;
		if (n) {
			*p++ = 3;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->api.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->uid.len;
		if (n) {
			*p++ = 4;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->uid.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->IP.len;
		if (n) {
			*p++ = 5;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->IP.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->ver.len;
		if (n) {
			*p++ = 6;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->ver.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->usid.len;
		if (n) {
			*p++ = 7;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->usid.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->errortype.len;
		if (n) {
			*p++ = 8;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->errortype.utf8, n);
			p += n;
		}
	}

	{
		size_t n = o->dataerr.len;
		if (n) {
			*p++ = 9;

			uint_fast32_t x = n;
			for (; x >= 128; x >>= 7) *p++ = x | 128;
			*p++ = x;

			memcpy(p, o->dataerr.utf8, n);
			p += n;
		}
	}

	*p++ = 127;

	return p - (uint8_t*) buf;
}

size_t main_ASER_unmarshal(main_ASER* o, const void* data, size_t datalen) {
	// octet pointer navigation
	const uint8_t* p = data;
	const uint8_t* end;
	int enderr;
	if (datalen < colfer_size_max) {
		end = p + datalen;
		enderr = EWOULDBLOCK;
	} else {
		end = p + colfer_size_max;
		enderr = EFBIG;
	}

	if (p >= end) {
		errno = enderr;
		return 0;
	}
	uint_fast8_t header = *p++;

	if (header == 0) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->form.len = n;

		void* a = malloc(n);
		o->form.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 1) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->model.len = n;

		void* a = malloc(n);
		o->model.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 2) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->os.len = n;

		void* a = malloc(n);
		o->os.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 3) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->api.len = n;

		void* a = malloc(n);
		o->api.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 4) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->uid.len = n;

		void* a = malloc(n);
		o->uid.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 5) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->IP.len = n;

		void* a = malloc(n);
		o->IP.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 6) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->ver.len = n;

		void* a = malloc(n);
		o->ver.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 7) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->usid.len = n;

		void* a = malloc(n);
		o->usid.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 8) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->errortype.len = n;

		void* a = malloc(n);
		o->errortype.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header == 9) {
		if (p >= end) {
			errno = enderr;
			return 0;
		}
		size_t n = *p++;
		if (n > 127) {
			n &= 127;
			for (int shift = 7; shift < sizeof(size_t) * CHAR_BIT; shift += 7) {
				if (p >= end) {
					errno = enderr;
					return 0;
				}
				size_t c = *p++;
				if (c <= 127) {
					n |= c << shift;
					break;
				}
				n |= (c & 127) << shift;
			}
		}
		if (n > colfer_size_max) {
			errno = EFBIG;
			return 0;
		}
		if (p+n >= end) {
			errno = enderr;
			return 0;
		}
		o->dataerr.len = n;

		void* a = malloc(n);
		o->dataerr.utf8 = (char*) a;
		if (n) {
			memcpy(a, p, n);
			p += n;
		}
		header = *p++;
	}

	if (header != 127) {
		errno = EILSEQ;
		return 0;
	}

	return (size_t) (p - (const uint8_t*) data);
}
