// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file structdef.colf for package main.

#ifndef COLFER_H
#define COLFER_H

#include <limits.h>
#include <stdint.h>
#include <string.h>

#if CHAR_BIT != 8
#error "octet byte size"
#endif

#ifdef __cplusplus
extern "C" {
#endif


// colfer_size_max is the upper limit for serial octet sizes.
extern size_t colfer_size_max;

// colfer_list_max is the upper limit for the number of elements in a list.
extern size_t colfer_list_max;


// colfer_text is a UTF-8 CLOB.
typedef struct {
	const char*  utf8;
	size_t       len;
} colfer_text;

// colfer_binary is a BLOB.
typedef struct {
	uint8_t* octets;
	size_t   len;
} colfer_binary;


typedef struct main_ASPI main_ASPI;

typedef struct main_SAPO main_SAPO;

typedef struct main_ASPO main_ASPO;

typedef struct main_SAPI main_SAPI;

typedef struct main_ASRR main_ASRR;

typedef struct main_SARR main_SARR;

typedef struct main_RGI1_data main_RGI1_data;

typedef struct main_ASRV main_ASRV;

typedef struct main_SARV main_SARV;

typedef struct main_ASRM main_ASRM;

typedef struct main_SARM main_SARM;

typedef struct main_ASRC main_ASRC;

typedef struct main_ASAU main_ASAU;

typedef struct main_CSNG main_CSNG;

typedef struct main_SCNG main_SCNG;

typedef struct main_MSNG main_MSNG;

typedef struct main_SMNG main_SMNG;

typedef struct main_ASER main_ASER;



struct main_ASPI {

	uint16_t rnd;
};

// main_ASPI_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_ASPI_marshal_len(const main_ASPI* o);

// main_ASPI_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_ASPI_marshal(const main_ASPI* o, void* buf);

// main_ASPI_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_ASPI_unmarshal(main_ASPI* o, const void* data, size_t datalen);


struct main_SAPO {

	uint16_t rnd;
};

// main_SAPO_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_SAPO_marshal_len(const main_SAPO* o);

// main_SAPO_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_SAPO_marshal(const main_SAPO* o, void* buf);

// main_SAPO_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_SAPO_unmarshal(main_SAPO* o, const void* data, size_t datalen);


struct main_ASPO {

	uint16_t rnd;
};

// main_ASPO_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_ASPO_marshal_len(const main_ASPO* o);

// main_ASPO_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_ASPO_marshal(const main_ASPO* o, void* buf);

// main_ASPO_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_ASPO_unmarshal(main_ASPO* o, const void* data, size_t datalen);


struct main_SAPI {

	uint16_t rnd;
};

// main_SAPI_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_SAPI_marshal_len(const main_SAPI* o);

// main_SAPI_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_SAPI_marshal(const main_SAPI* o, void* buf);

// main_SAPI_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_SAPI_unmarshal(main_SAPI* o, const void* data, size_t datalen);


struct main_ASRR {

	uint16_t rnd;

	colfer_text form;

	colfer_text model;

	colfer_text os;

	colfer_text api;

	colfer_text uid;

	colfer_text IP;

	colfer_text mcc1;

	colfer_text mcc2;

	colfer_text lang;
};

// main_ASRR_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_ASRR_marshal_len(const main_ASRR* o);

// main_ASRR_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_ASRR_marshal(const main_ASRR* o, void* buf);

// main_ASRR_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_ASRR_unmarshal(main_ASRR* o, const void* data, size_t datalen);


struct main_SARR {

	uint16_t rnd;

	colfer_text form;

	colfer_text error;

	colfer_text dataerr;

	struct {
		struct main_RGI1_data* list;
		size_t len;
	} data;
};

// main_SARR_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_SARR_marshal_len(const main_SARR* o);

// main_SARR_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_SARR_marshal(const main_SARR* o, void* buf);

// main_SARR_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_SARR_unmarshal(main_SARR* o, const void* data, size_t datalen);


struct main_RGI1_data {

	colfer_text country;

	colfer_text regcode;

	uint8_t min;

	uint8_t max;

	colfer_text numex;
};

// main_RGI1_data_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_RGI1_data_marshal_len(const main_RGI1_data* o);

// main_RGI1_data_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_RGI1_data_marshal(const main_RGI1_data* o, void* buf);

// main_RGI1_data_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_RGI1_data_unmarshal(main_RGI1_data* o, const void* data, size_t datalen);


struct main_ASRV {

	uint16_t rnd;

	colfer_text form;

	colfer_text model;

	colfer_text os;

	colfer_text api;

	colfer_text uid;

	colfer_text IP;

	colfer_text ver;
};

// main_ASRV_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_ASRV_marshal_len(const main_ASRV* o);

// main_ASRV_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_ASRV_marshal(const main_ASRV* o, void* buf);

// main_ASRV_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_ASRV_unmarshal(main_ASRV* o, const void* data, size_t datalen);


struct main_SARV {

	uint16_t rnd;

	colfer_text form;

	colfer_text error;

	colfer_text dataerr;
};

// main_SARV_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_SARV_marshal_len(const main_SARV* o);

// main_SARV_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_SARV_marshal(const main_SARV* o, void* buf);

// main_SARV_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_SARV_unmarshal(main_SARV* o, const void* data, size_t datalen);


struct main_ASRM {

	uint16_t rnd;

	colfer_text form;

	colfer_text model;

	colfer_text os;

	colfer_text api;

	colfer_text uid;

	colfer_text IP;

	colfer_text regcode;

	colfer_text mobile;

	colfer_text utype;

	colfer_text imsi1;

	colfer_text imsi2;

	colfer_text mcc1;

	colfer_text mcc2;
};

// main_ASRM_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_ASRM_marshal_len(const main_ASRM* o);

// main_ASRM_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_ASRM_marshal(const main_ASRM* o, void* buf);

// main_ASRM_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_ASRM_unmarshal(main_ASRM* o, const void* data, size_t datalen);


struct main_SARM {

	uint16_t rnd;

	colfer_text form;

	colfer_text error;

	colfer_text dataerr;

	colfer_text usid;

	colfer_text token;
};

// main_SARM_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_SARM_marshal_len(const main_SARM* o);

// main_SARM_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_SARM_marshal(const main_SARM* o, void* buf);

// main_SARM_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_SARM_unmarshal(main_SARM* o, const void* data, size_t datalen);


struct main_ASRC {

	colfer_text by;

	uint16_t rnd;

	colfer_text form;

	colfer_text model;

	colfer_text os;

	colfer_text api;

	colfer_text uid;

	colfer_text IP;

	colfer_text regcode;

	colfer_text mobile;

	colfer_text vrfcode;
};

// main_ASRC_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_ASRC_marshal_len(const main_ASRC* o);

// main_ASRC_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_ASRC_marshal(const main_ASRC* o, void* buf);

// main_ASRC_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_ASRC_unmarshal(main_ASRC* o, const void* data, size_t datalen);


struct main_ASAU {

	colfer_text token;

	uint64_t time;

	float timezone;
};

// main_ASAU_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_ASAU_marshal_len(const main_ASAU* o);

// main_ASAU_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_ASAU_marshal(const main_ASAU* o, void* buf);

// main_ASAU_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_ASAU_unmarshal(main_ASAU* o, const void* data, size_t datalen);


struct main_CSNG {

	colfer_text m;

	double glon;

	double glat;
};

// main_CSNG_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_CSNG_marshal_len(const main_CSNG* o);

// main_CSNG_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_CSNG_marshal(const main_CSNG* o, void* buf);

// main_CSNG_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_CSNG_unmarshal(main_CSNG* o, const void* data, size_t datalen);


struct main_SCNG {

	colfer_text m;
};

// main_SCNG_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_SCNG_marshal_len(const main_SCNG* o);

// main_SCNG_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_SCNG_marshal(const main_SCNG* o, void* buf);

// main_SCNG_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_SCNG_unmarshal(main_SCNG* o, const void* data, size_t datalen);


struct main_MSNG {

	uint16_t x;
};

// main_MSNG_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_MSNG_marshal_len(const main_MSNG* o);

// main_MSNG_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_MSNG_marshal(const main_MSNG* o, void* buf);

// main_MSNG_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_MSNG_unmarshal(main_MSNG* o, const void* data, size_t datalen);


struct main_SMNG {

	colfer_text c;

	double glon;

	double glat;
};

// main_SMNG_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_SMNG_marshal_len(const main_SMNG* o);

// main_SMNG_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_SMNG_marshal(const main_SMNG* o, void* buf);

// main_SMNG_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_SMNG_unmarshal(main_SMNG* o, const void* data, size_t datalen);


struct main_ASER {

	colfer_text form;

	colfer_text model;

	colfer_text os;

	colfer_text api;

	colfer_text uid;

	colfer_text IP;

	colfer_text ver;

	colfer_text usid;

	colfer_text errortype;

	colfer_text dataerr;
};

// main_ASER_marshal_len returns the Colfer serial octet size.
// When the return is zero then errno is set to EFBIG to indicate a breach of
// either colfer_size_max or colfer_list_max.
size_t main_ASER_marshal_len(const main_ASER* o);

// main_ASER_marshal encodes o as Colfer into buf and returns the number
// of octets written.
size_t main_ASER_marshal(const main_ASER* o, void* buf);

// main_ASER_unmarshal decodes data as Colfer into o and returns the
// number of octets read. The data is read up to a maximum of datalen or
// colfer_size_max, whichever occurs first.
// When the return is zero then errno is set to one of the following 3 values:
// EWOULDBLOCK on incomplete data, EFBIG on a breach of either colfer_size_max
// or colfer_list_max and EILSEQ on schema mismatch.
size_t main_ASER_unmarshal(main_ASER* o, const void* data, size_t datalen);


#ifdef __cplusplus
} // extern "C"
#endif

#endif
